---
# -------------------------------------
# REQUIRED & COMMON FIELDS
# -------------------------------------
title: "Temperaturen in der Nacht"
author: "Robin Kohrs / Netzwerk Klimajournalismus"
date: "2025-04-27" # Use specific date, or "today" to auto-update on render
date-format: "DD MMMM YYYY" # Optional: How the date is displayed (e.g., 17 October 2023)

# -------------------------------------
# OPTIONAL DESCRIPTIVE FIELDS
# -------------------------------------
# subtitle: "SUBTITLE:..." # Optional additional detail
# abstract: | # Optional multi-line summary of the analysis goals/findings
  # Abstract
keywords: [climate data, analysis, netzwerk klimajournalismus, topic1, topic2] # Optional keywords

# -------------------------------------
# CUSTOM FIELDS (Examples - Adapt as needed)
# -------------------------------------
# You can define any key-value pairs here. They can sometimes be accessed
# within your document or code (e.g., via quarto::quarto_metadata()).
analysis:
  id: "NKA-YYYY-NN" # Example: Internal analysis ID
  version: "1.0" # Version of this specific analysis document
  status: "Draft" # E.g., Draft, In Review, Final
  lead: "Person Responsible"
data:
  source: "[Name of Data Provider/URL]"
  accessed: "YYYY-MM-DD" # Date data was downloaded/accessed
  processing_script: "[Path to script, if any]" # Reference R script used

# -------------------------------------
# EXECUTION OPTIONS (Control R/Python code execution)
# -------------------------------------
execute:
  echo: false # Set to 'true' to show code chunks by default
  warning: false # Set to 'true' to show warnings
  message: false # Set to 'true' to show messages
  # cache: true # Uncomment to cache results of computations (speeds up re-rendering)
  # error: true # Set to 'false' to stop rendering on code errors

---




```{r setup, include=FALSE}
# Essential setup chunk - load packages, etc.
knitr::opts_chunk$set(echo = TRUE, # Override global echo=false for this chunk if needed
                      warning = FALSE,
                      message = FALSE)

library(devtools)

# Load other libraries
library(tidyverse)
library(glue)
library(DT)
library(davR)
library(here)

data_raw_path = davR::sys_make_path(
  file.path(
    here(),
    "wiki",
    "data_raw",
    "kjn",
    "2025-05-tropennächte",
    "daily_min_data"
  )
)

data_raw_path_hourly_data = davR::sys_make_path(
  file.path(
    here(),
    "wiki",
    "data_raw",
    "kjn",
    "2025-05-tropennächte",
    "hourly_data"
  )
)

```

## Minimaltemperaturen

### Welche Datensätze bei der Geosphere eignen sich?

- Ein-Tagesdaten mit der Minimaltemperatur zwischen 18 und 18 Uhr

- Annahme: Die Minimaltemperaturen steigen

:::{.callout-note}
## `klima-v2-1d` ist am geignetsten
:::

### Was wollen wir zeigen?

1. **Die Intensität der Tropnnächte: ** Nicht nur die Anzahl an Tropennächten sondern die minimale Temperatur


### Welche Stationen nehmen den Temperaturparamter auf?

- Nur Wien?

- Alle Landeshauptstädte?

-> Die kombinierte Station an der Wiener Hohen Warte misst seit 1872


:::{.callout-note collapse=true}
```{r welcheStationen}
meta = geosphere_explore_resource("klima-v2-1h")
# tl -> paramter für Lufttemperatur in 2m
```

```{r define_params}
resource_id = "klima-v2-1d"
parameters = c("tlmin")
year_start=1900
year_end=2025
month_start =4
month_end = 10
station_ids = c(105)
```

:::


### Get the data

```{r download_daily_data}
# download the data
walk(year_start:year_end, function(year) {
  cli::cli_inform(glue("In year: {year}"))
  # get data for one month for one year
    start_param = glue("{year}-{month_start}-01")
    days_in_end_month  = lubridate::days_in_month(as.Date(glue("{year}-{month_end}-01")))
    end_param = glue("{year}-{month_end}-{days_in_end_month}")
    
    # output path
    fn = glue("{year}_M{month_start}_to_M{month_end}.csv")
    op = sys_make_path(file.path(data_raw_path, fn))
    
    if(file.exists(op)) return()
    
    tryCatch({
      path = geosphere_get_data(
        resource_id = resource_id,
        parameters = parameters,
        start = start_param,
        end = end_param,
        station_ids = station_ids,
        output_format = "csv",
        version = 1,
        mode = "historical",
        type = "station",
        output_file = op,
        verbose = T,
        debug = F
      )
   }, error = function(e){
       cli::cli_warn("Failed processing {year}-{month}: {conditionMessage(e)}")
       return(NULL) # Return NULL on error
   })
})

# list all the files
files_each_year = dir(data_raw_path, ".*\\.csv", full.names = T)
data_each_year = files_each_year %>% map(~data.table::fread(.x)) %>% bind_rows()
```

### for each month get all the yearly data

```{r}
#| fig-width: 7
#| fig-height: 12

# Prepare data for plotting
df_prepared <- data_each_year %>%
  # Ensure time is in Date format if not already
    mutate(time = as_datetime(time, format = "%Y-%m-%dT%H:%M%z")) %>% 
  # Extract date components
  mutate(
    year = year(time),
    month_num = month(time),
    # Create month factor with labels for nice facet titles
    month_lbl = month(time, label = TRUE, abbr = FALSE),
    day = day(time)
  ) %>%
  # Filter out rows where tlmin is NA, as they can't be plotted
  filter(!is.na(tlmin)) %>%
  # Optional: Filter for a specific station if your df has multiple
  # filter(station == 105) %>%
  # Arrange for potentially smoother plotting (optional)
  arrange(year, month_num, day)


# Define the cutoff year
highlight_year <- 2020

# Create the plot
p <- ggplot(df_prepared, aes(x = day, y = tlmin)) +

  # Layer 1: Historical years (before highlight_year) in grey
  geom_line(
    data = . %>% filter(year < highlight_year), # Filter data for this layer
    aes(group = year),                          # Group by year to get separate lines
    color = "grey70",                           # Set color to light grey
    alpha = 0.7                                 # Make slightly transparent
  ) +

  # Layer 2: Recent years (highlight_year onwards) colored by year
  geom_line(
    data = . %>% filter(year >= highlight_year), # Filter data for this layer
    aes(color = factor(year), group = year),    # Color by year (as factor)
    linewidth = 0.8                             # Make recent lines slightly thicker (optional)
  ) +

  # Facet by month - creates the grid of plots
  facet_wrap(~ month_lbl, ncol = 1) + # Adjust ncol as needed

  # Apply a nice color scale for the recent years
  scale_color_viridis_d(
      option = "plasma",      # Viridis palette options: "magma", "plasma", "inferno", "viridis", "cividis"
      end = 0.9               # Avoid the brightest color (often yellow)
  ) +

  # Add labels and title
  labs(
    title = "Daily Minimum Temperatures by Month and Year",
    subtitle = paste("Years since", highlight_year, "highlighted. Station:", first(df_prepared$station)), # Adjust if needed
    x = "Day of Month",
    y = "Minimum Temperature (°C)",
    color = "Recent Year" # Legend title for the color scale
  ) +

  # Apply a clean theme
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom", # Or "right", "left", "top"
    strip.text = element_text(face = "bold") # Make facet titles bold
   )

# Print the plot
print(p)

# Optional: Save the plot
# ggsave("temperature_plot.png", plot = p, width = 14, height = 10, dpi = 300)
```


## Durschnittstemperatur in der Nacht im Juli


```{r}
resource_id = "klima-v2-1h"
start_year = 1900
end_year = 2025
month = 7

ex = geosphere_explore_resource("klima-v2-1h")

data_list = map(start_year:end_year, function(year){
  start = glue("{year}-{month}-01")
  last_day_in_month = lubridate::days_in_month(glue("{year}-{month}-01"))
  end = glue("{year}-{month}-{last_day_in_month}")

    fn = glue("{year}_{month}.csv")
    op = sys_make_path(file.path(data_raw_path_hourly_data, fn))
    print(op)
    if(file.exists(op)) return(NULL)
    result = tryCatch({
      data = geosphere_get_data(
        resource_id = resource_id,
        parameters = c("tl"),
        start = start,
        end = end,
        station_ids = 105,
        type = "station",
        mode = "historical",
        output_file = op
      ) %>% data.table::fread()
    }, error = function(e) {
      cli::cli_warn("Failed processing {year}-{month}: {conditionMessage(e)}")
      return(NULL) # Return NULL on error
    })

    return(result)
})

data_hourly = keep(data_list, ~!is.null(.x)) %>% bind_rows()
```





