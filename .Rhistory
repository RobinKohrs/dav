vjust = 0.5,
hjust = 0.3,
size = 5.8,
color = color_articles,
family = font_family,
fontface = "bold",
check_overlap = TRUE
) +
# COP Conference markers - positioned at actual coverage values for those months
geom_point(
data = cop_conferences %>%
left_join(
data_with_trend %>% select(date, Coverage),
by = "date"
) %>%
filter(!is.na(Coverage)),
aes(x = date, y = Coverage, color = "COP-Konferenzen"),
size = 4,
alpha = 0.3,
shape = 1,
stroke = 2
) +
# Annotation lines for specific COP conferences
geom_segment(
data = cop_conferences %>%
left_join(
data_with_trend %>% select(date, Coverage),
by = "date"
) %>%
filter(!is.na(Coverage)) %>%
filter(cop %in% c("COP 15", "COP 26")) %>%
mutate(
label_x = case_when(
cop == "COP 15" ~ date + 500, # Position label to the right
cop == "COP 26" ~ date - 1100 # Position label to the left
),
label_y = case_when(
cop == "COP 15" ~ Coverage + 200,
cop == "COP 26" ~ Coverage + 0
)
),
aes(x = date, y = Coverage, xend = label_x, yend = label_y),
color = "grey30",
linewidth = 0.4,
alpha = 0.7
) +
# Label for COP 15 (positioned to the right)
geom_text(
data = cop_conferences %>%
left_join(
data_with_trend %>% select(date, Coverage),
by = "date"
) %>%
filter(!is.na(Coverage)) %>%
filter(cop == "COP 15") %>%
mutate(
label_x = date + 500,
label_y = Coverage + 200
),
aes(x = label_x, y = label_y, label = "COP15\nKopenhagen"),
vjust = 0.5,
hjust = 0, # left-align
size = 4.4,
color = "grey30",
family = font_family,
fontface = "bold"
) +
# Label for COP 26 (positioned to the left)
geom_text(
data = cop_conferences %>%
left_join(
data_with_trend %>% select(date, Coverage),
by = "date"
) %>%
filter(!is.na(Coverage)) %>%
filter(cop == "COP 26") %>%
mutate(
label_x = date - 1200,
label_y = Coverage + 150
),
aes(x = label_x, y = label_y, label = "COP26\nGlasgow"),
vjust = 1,
hjust = 1, # right-align
size = 4.4,
color = "grey30",
family = font_family,
fontface = "bold"
) +
geom_smooth(
aes(y = Coverage, linetype = "Langzeit-Trend"),
method = "loess",
formula = y ~ x,
se = FALSE,
linewidth = smooth_line_width,
colour = color_loess,
span = 0.3
) +
# Color scales
scale_color_manual(
name = NULL,
values = c(
"Monatlich" = color_articles,
"COP-Konferenzen" = "black"
),
labels = c(
"Monatlich" = glue(
"<span style='color:{color_articles};'>monatliche Werte</span>"
),
"COP-Konferenzen" = "<span style='color:black;'>COP-Konferenzen</span>"
)
) +
# Linetype scale for trend
# scale_linetype_manual(
#     name = "aaa",
#     values = c("Langzeit-Trend" = "dashed"),
#     labels = c(
#         "Langzeit-Trend" = glue(
#             "<span style='color:{color_loess};'>Langzeit-Trend</span>"
#         )
#     )
# ) +
# Scales
scale_y_continuous(
breaks = scales::pretty_breaks(n = 5),
labels = scales::number_format(big.mark = ".", decimal.mark = ",")
) +
scale_x_date(
breaks = as.Date(c(
"2005-01-01",
"2010-01-01",
"2015-01-01",
"2020-01-01"
)),
labels = c("2005", "2010", "2015", "2020"),
expand = expansion(mult = c(0.02, 0.02))
) +
# Labels
labs(
title = glue(
"<span style='font-weight: 200; font-size:{title_px_ggtext}px; color:{color_text_primary};'><b style='font-family: Roboto-Bold;'>Klimaberichterstattung</b> nimmt wieder ab</span>"
),
subtitle = glue(
"<span style='font-size:{subtitle_px_ggtext}px; color:{color_text_secondary};'>Anzahl der monatlichen Beiträge in ausgewählten europäischen Tageszeitungen</span>"
),
x = NULL,
y = glue(
"<span style='font-size:{.pt_to_px(axis_title_pt)}px; color:{color_text_primary};'>Anzahl Beiträge</span>"
),
caption = glue(
"<b style='font-family: Roboto-Bold; color:{color_text_primary};'>Methodik:</b> <i style='color:{color_text_secondary};'>Monitoring von 33 europäischen Zeitungen mit Suchbegriffen 'climate change',<br>'global warming', 'Klimawandel', 'cambio climático' über Datenbanken wie Factiva oder NexisUni</i><br>",
"<b style='font-family: Roboto-Bold; color:{color_text_primary};'>Daten:</b> <i style='color:{color_text_secondary};'>Osborne-Gowey, Jeremiah, et al. European Newspaper Coverage of Climate Change Or<br> Global Warming, 2004-2025 - June 2025</i>"
)
) +
# Guides
guides(
color = guide_legend(
override.aes = list(
label = "",
shape = c(1, 19), # solid circle for monthly, hollow circle for COP
stroke = c(2, 0), # no stroke for monthly, thick stroke for COP
size = c(3, 4), # different sizes to match the plot
alpha = c(.3, .9) # solid for monthly, transparent for COP
)
),
linetype = guide_legend(override.aes = list(label = ""))
) +
# Theme
theme_minimal(base_size = base_font_size_pt, base_family = font_family) +
theme(
# Backgrounds
plot.background = element_rect(fill = "white", colour = NA),
panel.background = element_rect(fill = "white", colour = NA),
legend.background = element_rect(fill = "transparent", colour = NA),
legend.key = element_rect(fill = "transparent", colour = NA),
# Text styling
plot.title = element_markdown(
hjust = 0.0,
margin = margin(b = 10),
lineheight = 1.1
),
plot.subtitle = element_markdown(
hjust = 0.0,
margin = margin(b = -30),
lineheight = 1.6
),
# Axis styling
axis.title.x = element_blank(),
axis.title.y = element_markdown(
margin = margin(r = 5),
size = rel(axis_title_pt / base_font_size_pt)
),
axis.text = element_text(
colour = color_text_secondary,
size = rel(axis_text_pt / base_font_size_pt)
),
axis.text.x = element_text(margin = margin(t = 2)),
axis.text.y = element_text(margin = margin(r = 2)),
# Caption
plot.caption = element_markdown(
hjust = 0,
margin = margin(t = 15),
size = rel(caption_pt / base_font_size_pt),
lineheight = 1.3,
colour = color_caption_text
),
plot.title.position = "plot",
plot.caption.position = "plot",
# Legend
legend.position = "bottom",
legend.box = "horizontal",
legend.text = element_markdown(
size = rel(legend_text_pt / base_font_size_pt)
),
legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
legend.spacing.x = unit(0.2, "cm"),
legend.title = element_blank(),
# Grid
panel.grid.minor = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.major.y = element_line(
colour = color_grid_lines,
linewidth = 0.3
),
# Margins
plot.margin = margin(
t = plot_margin_t,
r = plot_margin_r,
b = plot_margin_b,
l = plot_margin_l,
unit = "pt"
)
)
# Display the plot
print(climate_coverage_plot)
# Save the plot
output_dir <- file.path(
"wiki",
"climate-analyses",
"kjn",
"2025-08-klimaberichterstattung"
)
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
}
plot_filename_png <- file.path(
output_dir,
"klimaberichterstattung_entwicklung.png"
)
plot_filename_svg <- file.path(
output_dir,
"klimaberichterstattung_entwicklung.svg"
)
# Save as PNG
ggsave(
filename = plot_filename_png,
plot = climate_coverage_plot,
device = png,
width = plot_width_in,
height = plot_height_in,
units = "in",
dpi = plot_dpi,
bg = "white"
)
# Save as SVG (using svglite to avoid Cairo dependencies)
ggsave(
filename = plot_filename_svg,
plot = climate_coverage_plot,
device = svglite::svglite,
width = plot_width_in,
height = plot_height_in,
units = "in",
bg = "white"
)
cli_alert_success(
"Climate coverage plot saved as PNG: {.path {plot_filename_png}}"
)
cli_alert_success(
"Climate coverage plot saved as SVG: {.path {plot_filename_svg}}"
)
devtools::document()
devtools::install(quick=T)
aoi_path="/Users/rk/projects/dst/misc/ME/projects/PLANET_IMAGES/gaza_city_east_extent.gpkg"
tile_index_path = "/Volumes/rr/Planet Images/Gaza/gaza_tile_index.gpkg"
output_dir="/Users/rk/projects/dst/misc/ME/projects/PLANET_IMAGES/03_10_2025_get_gaza_city_imges_for_polygon/"
overlap_threshold = .5
library(sf)
library(terra)
library(tidyverse)
# --- 1. Input Validation ---
# Ensure the 'terra' package is installed
if (!requireNamespace("terra", quietly = TRUE)) {
stop(
"Package 'terra' is required but not installed. Please run: install.packages('terra')"
)
}
stopifnot(
"Error: aoi_path does not exist. Please check the file path." = file.exists(
aoi_path
),
"Error: tile_index_path does not exist. Please check the file path." = file.exists(
tile_index_path
),
"Error: overlap_threshold must be a number between 0 and 1." = is.numeric(
overlap_threshold
) &&
overlap_threshold >= 0 &&
overlap_threshold <= 1
)
cat("--- Starting Raster Processing ---\n")
# --- 2. Setup and Data Loading ---
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE)
cat("Created output directory at:", output_dir, "\n")
}
cat("Loading spatial data using 'terra'...\n")
tile_index <- terra::vect(tile_index_path)
tile_index
aoi <- terra::vect(aoi_path)
aoi
# Ensure CRS Consistency
cat("Checking Coordinate Reference Systems (CRS)...\n")
if (terra::crs(tile_index) != terra::crs(aoi)) {
cat("CRS mismatch. Reprojecting AOI to match the tile index CRS.\n")
aoi <- terra::project(aoi, terra::crs(tile_index))
} else {
cat("CRS match. No reprojection needed.\n")
}
# --- 3. Filter Rasters by Overlap ---
cat("Finding intersecting raster footprints...\n")
candidates <- tile_index[aoi, ]
candidates
if (nrow(candidates) == 0) {
message(
"No rasters were found intersecting the AOI. The function will now stop."
)
return(invisible(character(0)))
}
cat(
"Found",
nrow(candidates),
"candidate rasters. Calculating overlap percentage...\n"
)
aoi_area <- terra::expanse(aoi)
aoi_area
final_raster_list <- c()
i = 1
footprint <- candidates[i, ]
footprint
intersection_geom <- terra::intersect(aoi, footprint)
intersection_geom
overlap_ratio <- terra::expanse(intersection_geom) / aoi_area
overlap_ratio
if (overlap_ratio >= overlap_threshold) {
final_raster_list <- c(final_raster_list, footprint$location)
}
final_raster_list
candidates
final_raster_list <- c()
nrow(candidates)
final_raster_list <- c()
for (i in 1:nrow(candidates)) {
footprint <- candidates[i, ]
intersection_geom <- terra::intersect(aoi, footprint)
if (nrow(intersection_geom) > 0) {
overlap_ratio <- terra::expanse(intersection_geom) / aoi_area
if (overlap_ratio >= overlap_threshold) {
final_raster_list <- c(final_raster_list, footprint$location)
}
}
}
final_raster_list
if (length(final_raster_list) == 0) {
message(
"No rasters met the required ",
overlap_threshold * 100,
"% overlap threshold. The function will now stop."
)
return(invisible(character(0)))
}
cat(
"\nFound",
length(final_raster_list),
"rasters that meet the overlap criteria.\n"
)
# --- 4. Crop and Save Qualifying Rasters ---
cat("--- Starting the cropping process ---\n")
newly_created_files <- c()
i = 1
raster_path <- final_raster_list[i]
raster_path
cat(sprintf(
"Processing %d of %d: %s\n",
i,
length(final_raster_list),
basename(raster_path)
))
original_raster <- terra::rast(raster_path)
original_raster
cropped_raster <- terra::crop(original_raster, aoi, mask = TRUE)
aoi
crs(original_raster)
crs_raster = crs(original_raster)
aoi_projected = terra::project(aoi, crs_raster)
aoi_projected
cropped_raster <- terra::crop(original_raster, aoi, mask = TRUE)
cropped_raster <- terra::crop(original_raster, aoi_projected, mask = TRUE)
aoi_name = "cropped"
output_filename <- file.path(
output_dir,
paste0(aoi_name, "_", basename(raster_path))
)
output_filename
devtools::document()
devtools::document()
devtools::install(quick = T)
if (!requireNamespace("sf", quietly = TRUE)) {
stop(
"Package 'sf' is required to run this function. Please install it with install.packages('sf')."
)
}
# 1. Define proj4string for the front hemisphere
front_proj <- paste0(
"+proj=laea +lat_0=",
lat,
" +lon_0=",
lon,
" +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"
)
lat=51
lon=10
lat=51.5
# 1. Define proj4string for the front hemisphere
front_proj <- paste0(
"+proj=laea +lat_0=",
lat,
" +lon_0=",
lon,
" +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"
)
# 2. Define proj4string for the back hemisphere (antipodal)
back_lon <- ifelse(lon < 0, lon + 180, lon - 180)
back_lat <- -lat
back_proj <- paste0(
"+proj=laea +lat_0=",
back_lat,
" +lon_0=",
back_lon,
" +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"
)
# 3. Create clipping shapes
# For a LAEA projection, a hemisphere is projected onto a circle.
# The radius of this circle is sqrt(2) * R, where R is the radius of the Earth.
# We use the semi-major axis of the WGS84 ellipsoid.
earth_radius <- 6378137
clip_radius <- earth_radius * sqrt(2)
clip_radius
# Create a point at the origin (0,0) in the projected CRS and buffer it.
# nQuadSegs is used to create a smoother circle.
origin_pt <- sf::st_point(c(0, 0))
# Front clipping polygon
front_clip_sfc <- sf::st_sfc(origin_pt, crs = front_proj)
front_clip <- sf::st_buffer(
front_clip_sfc,
dist = clip_radius,
nQuadSegs = 50
)
front_clip
mapview(front_clip)
library(mapview)
mapview(front_clip)
write_sf(front_clip, "~/LIXO/front.fgb")
library(sf)
write_sf(front_clip, "~/LIXO/front.fgb")
front_proj
lat=0
lon=-100
# 1. Define proj4string for the front hemisphere
front_proj <- paste0(
"+proj=laea +lat_0=",
lat,
" +lon_0=",
lon,
" +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"
)
# 2. Define proj4string for the back hemisphere (antipodal)
back_lon <- ifelse(lon < 0, lon + 180, lon - 180)
back_lat <- -lat
back_proj <- paste0(
"+proj=laea +lat_0=",
back_lat,
" +lon_0=",
back_lon,
" +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"
)
# 3. Create clipping shapes
# For a LAEA projection, a hemisphere is projected onto a circle.
# The radius of this circle is sqrt(2) * R, where R is the radius of the Earth.
# We use the semi-major axis of the WGS84 ellipsoid.
earth_radius <- 6378137
clip_radius <- earth_radius * sqrt(2)
# Create a point at the origin (0,0) in the projected CRS and buffer it.
# nQuadSegs is used to create a smoother circle.
origin_pt <- sf::st_point(c(0, 0))
# Front clipping polygon
front_clip_sfc <- sf::st_sfc(origin_pt, crs = front_proj)
front_clip <- sf::st_buffer(
front_clip_sfc,
dist = clip_radius,
nQuadSegs = 50
)
write_sf(front_clip, "~/LIXO/front.fgb")
write_sf(front_clip, "~/LIXO/frontusa.fgb")
